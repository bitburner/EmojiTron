<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EmojiTron V5 - Boss Updates!</title>
    <style>
        /* --- CSS Unchanged --- */
        body { margin: 0; overflow: hidden; background-color: #222; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif; color: white; }
        canvas { border: 1px solid #555; background-color: #333; display: block; }
        #ui { position: absolute; top: 10px; left: 10px; font-size: 18px; text-shadow: 1px 1px 2px black; z-index: 5; }
        #levelUpModal { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.85); border: 2px solid #ccc; padding: 30px; text-align: center; z-index: 10; }
        #levelUpModal h2 { margin-top: 0; color: #ffd700; }
        .upgradeOption { background-color: #444; border: 1px solid #888; color: white; padding: 15px; margin: 10px 0; cursor: pointer; font-size: 16px; display: block; width: 350px; text-align: left; transition: background-color 0.2s; }
        .upgradeOption:hover { background-color: #666; }
        #gameOverScreen { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.9); border: 2px solid #ff0000; padding: 40px; text-align: center; z-index: 10; }
        #gameOverScreen h2 { color: #ff0000; margin-bottom: 20px; }
        #restartButton { background-color: #555; border: 1px solid #aaa; color: white; padding: 10px 20px; font-size: 18px; cursor: pointer; margin-top: 20px; }
        #restartButton:hover { background-color: #777; }
        #bossInfo { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 60%; max-width: 600px; text-align: center; z-index: 5; display: none; }
        #bossHpBar { height: 15px; background-color: #dc3545; border: 1px solid #eee; border-radius: 5px; overflow: hidden; }
        #bossHpFill { height: 100%; width: 100%; background-color: #ffc107; transition: width 0.2s ease-out; }
        #bossName { font-size: 20px; margin-bottom: 5px; text-shadow: 1px 1px 3px black; }
    </style>
</head>
<body>
    <!-- --- HTML Structure Unchanged --- -->
    <div id="ui">
        <div>Time: <span id="timer">0:00</span></div>
        <div>Wave: <span id="wave">1</span></div>
        <div>Level: <span id="level">1</span></div>
        <div>HP: <span id="hp">100</span> / <span id="maxHp">100</span></div>
        <div>XP: <span id="xp">0</span> / <span id="nextLevelXp">10</span></div>
        <div>Armor: <span id="armor">0</span></div>
        <div>XP Mult: <span id="xpMult">1.0x</span></div>
    </div>
    <div id="bossInfo"> <div id="bossName">👾 BOSS 👾</div> <div id="bossHpBar"> <div id="bossHpFill"></div> </div> </div>
    <canvas id="gameCanvas"></canvas>
    <div id="levelUpModal"> <h2>Level Up! Choose an Upgrade:</h2> <button class="upgradeOption" id="upgrade1"></button> <button class="upgradeOption" id="upgrade2"></button> <button class="upgradeOption" id="upgrade3"></button> </div>
    <div id="gameOverScreen"> <h2>Game Over!</h2> <div>Survived for: <span id="finalTime">0:00</span></div> <div>Final Level: <span id="finalLevel">1</span></div> <div>Highest Wave: <span id="finalWave">1</span></div> <button id="restartButton">Restart Game</button> </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- UI Elements --- (references unchanged)
        const uiHp = document.getElementById('hp'); const uiMaxHp = document.getElementById('maxHp'); const uiLevel = document.getElementById('level'); const uiXp = document.getElementById('xp'); const uiNextLevelXp = document.getElementById('nextLevelXp'); const uiTimer = document.getElementById('timer'); const uiWave = document.getElementById('wave'); const uiArmor = document.getElementById('armor'); const uiXpMult = document.getElementById('xpMult'); const levelUpModal = document.getElementById('levelUpModal'); const upgradeOptionButtons = [ document.getElementById('upgrade1'), document.getElementById('upgrade2'), document.getElementById('upgrade3') ]; const gameOverScreen = document.getElementById('gameOverScreen'); const finalTimeEl = document.getElementById('finalTime'); const finalLevelEl = document.getElementById('finalLevel'); const finalWaveEl = document.getElementById('finalWave'); const restartButton = document.getElementById('restartButton'); const bossInfoDiv = document.getElementById('bossInfo'); const bossHpFillDiv = document.getElementById('bossHpFill');

        // --- Game Settings --- (unchanged from V4)
        const PLAYER_SIZE = 30; const ENEMY_SIZE = 25; const BOSS_SIZE = 50; const PROJECTILE_SIZE = 15; const ENEMY_PROJECTILE_SIZE = 20; const GEM_SIZE = 10; const CHEST_SIZE = 35; const HEALTH_PICKUP_SIZE = 25; const ORBITAL_SIZE = 20; const BOMB_PICKUP_SIZE = 30; const FIREBALL_SIZE = 20;
        const PLAYER_SPEED = 180; const ENEMY_BASE_SPEED = 90;
        const ENEMY_SPAWN_INTERVAL_BASE = 1200;
        const XP_PER_LEVEL_BASE = 10;
        const XP_PER_LEVEL_MULTIPLIER = 1.35;
        const GRID_SIZE = 50;
        const BASE_PICKUP_RADIUS = 60; const GEM_MAGNET_ACCELERATION = 150; const GEM_MAX_MAGNET_SPEED = 300;
        const INVULNERABILITY_DURATION = 500;
        const CHEST_SPAWN_CHANCE = 0.02;
        const CHEST_LIFESPAN = 7000; const CHEST_XP_REWARD = 15;
        const HEALTH_SPAWN_CHANCE = 0.005;
        const HEALTH_PICKUP_LIFESPAN = 6000;
        const BOMB_SPAWN_CHANCE = 0.002;
        const BOMB_PICKUP_LIFESPAN = 8000;
        const MAX_WEAPONS = 4;

        // --- Wave Data --- (unchanged)
        const waveData = [ { duration: 45, types: ['skull'], density: 0.7, boss: false }, { duration: 60, types: ['skull', 'ogre'], density: 1.3, boss: false }, { duration: 75, types: ['ghost'], density: 1.8, boss: false }, { duration: 0, types: ['boss'], density: 1.0, boss: true }, { duration: 90, types: ['skull', 'ghost', 'alien'], density: 2.0, boss: false }, { duration: 120, types: ['ogre', 'alien'], density: 1.8, boss: false }, { duration: 0, types: ['boss'], density: 1.0, boss: true }, { duration: Infinity, types: ['skull', 'ogre', 'ghost', 'alien'], density: 2.5, boss: false } ];

        // --- Game State --- (unchanged from V4)
        let player; let enemies = []; let projectiles = []; let enemyProjectiles = []; let xpGems = []; let treasureChests = []; let healthPickups = [];
        let bombPickups = []; let explosionEffects = [];
        let keys = {}; let gameTime = 0; let lastTime = 0; let deltaTime = 0; let currentWaveIndex = 0; let waveTimer = 0; let enemySpawnTimer = 0;
        let chestSpawnTimer = 0; let healthSpawnTimer = 0; let bombSpawnTimer = 0;
        let gameState = 'playing'; let gameLoopId; let isFirstFrame = true; let isBossActive = false; let currentBoss = null;

        // --- Player Class --- (unchanged from V4)
        class Player {
            constructor(x, y) { this.x = x; this.y = y; this.size = PLAYER_SIZE; this.emoji = '🦸'; this.speed = PLAYER_SPEED; this.maxHp = 100; this.hp = this.maxHp; this.xp = 0; this.level = 1; this.nextLevelXp = XP_PER_LEVEL_BASE; this.weapons = [new KnifeWeapon()]; this.pickupRadius = BASE_PICKUP_RADIUS; this.invulnerableTimer = 0; this.armor = 0; this.xpMultiplier = 1.0; }
            update(dt) { if (this.invulnerableTimer > 0) { this.invulnerableTimer -= dt * 1000; } if (gameState !== 'playing') return; let moveX = 0, moveY = 0; if (keys['w'] || keys['arrowup']) moveY -= 1; if (keys['s'] || keys['arrowdown']) moveY += 1; if (keys['a'] || keys['arrowleft']) moveX -= 1; if (keys['d'] || keys['arrowright']) moveX += 1; const length = Math.sqrt(moveX * moveX + moveY * moveY); let normalizedX = 0, normalizedY = 0; if (length > 0) { normalizedX = moveX / length; normalizedY = moveY / length; } this.x += normalizedX * this.speed * dt; this.y += normalizedY * this.speed * dt; this.x = Math.max(this.size / 2, Math.min(canvas.width - this.size / 2, this.x)); this.y = Math.max(this.size / 2, Math.min(canvas.height - this.size / 2, this.y)); this.weapons.forEach(weapon => weapon.update(dt, this.x, this.y)); }
            draw(ctx) { this.weapons.forEach(weapon => { if (typeof weapon.drawUnder === 'function') weapon.drawUnder(ctx, this.x, this.y); }); if (this.invulnerableTimer > 0) ctx.globalAlpha = (Math.floor(this.invulnerableTimer / 100) % 2 === 0) ? 1.0 : 0.5; ctx.font = `${this.size * 1.5}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.emoji, this.x, this.y); ctx.globalAlpha = 1.0; const barWidth = this.size * 1.5, barHeight = 5, barX = this.x - barWidth / 2, barY = this.y + this.size * 0.75; ctx.fillStyle = '#dc3545'; ctx.fillRect(barX, barY, barWidth, barHeight); ctx.fillStyle = '#28a745'; ctx.fillRect(barX, barY, barWidth * Math.max(0, this.hp / this.maxHp), barHeight); ctx.strokeStyle = '#eee'; ctx.lineWidth = 1; ctx.strokeRect(barX, barY, barWidth, barHeight); this.weapons.forEach(weapon => { if (typeof weapon.drawOver === 'function') weapon.drawOver(ctx, this.x, this.y); }); }
            takeDamage(amount) { if (gameState !== 'playing' || this.invulnerableTimer > 0) return; const damageTaken = Math.max(1, amount - this.armor); this.hp -= damageTaken; this.invulnerableTimer = INVULNERABILITY_DURATION; if (this.hp <= 0) { this.hp = 0; gameOver(); } updateUI(); }
            gainXp(amount) { if (gameState !== 'playing') return; this.xp += Math.floor(amount * this.xpMultiplier); if (this.xp >= this.nextLevelXp) this.levelUp(); updateUI(); }
            levelUp() { this.level++; const leftoverXp = this.xp - this.nextLevelXp; this.nextLevelXp = Math.floor(XP_PER_LEVEL_BASE * Math.pow(XP_PER_LEVEL_MULTIPLIER, this.level -1)); this.xp = Math.max(0, leftoverXp); pauseGameForLevelUp(); updateUI(); } // pauseGameForLevelUp is now also called on boss defeat
            restoreFullHealth() { console.log("Health Restored!"); this.hp = this.maxHp; updateUI(); }
            addWeapon(newWeaponInstance) { if (this.weapons.length < MAX_WEAPONS) { this.weapons.push(newWeaponInstance); console.log(`Added weapon: ${newWeaponInstance.constructor.name}`); return true; } console.log("Max weapons reached."); return false; }
        }

        // --- Weapon Classes --- (Base, Knife, Orbital, Aura, Fireball unchanged from V4)
        class Weapon { constructor() { this.level = 1; this.lastFireTime = 0; this.cooldown = 1000; this.damage = 10; } update(dt, playerX, playerY) {} fire(playerX, playerY) {} upgrade(type) {} getDescription(type) {} getNextUpgradeOptions() { return []; } }
        class KnifeWeapon extends Weapon { constructor() { super(); this.emoji = '🔪'; this.projectileSpeed = 350; this.projectileCount = 1; this.cooldown = 1200; this.damage = 15; this.lastFireTime = performance.now(); } update(dt, playerX, playerY) { if (gameState !== 'playing') return; const now = performance.now(); if (now - this.lastFireTime >= this.cooldown) { this.fire(playerX, playerY); this.lastFireTime = now; } } fire(playerX, playerY) { let nearestEnemy = null; let minDistSq = Infinity; enemies.concat(currentBoss ? [currentBoss] : []).forEach(enemy => { if (!enemy || !enemy.active) return; const distSq = (enemy.x - playerX)**2 + (enemy.y - playerY)**2; if (distSq < minDistSq) { minDistSq = distSq; nearestEnemy = enemy; } }); for (let i = 0; i < this.projectileCount; i++) { let angle; if (nearestEnemy) { const baseAngle = Math.atan2(nearestEnemy.y - playerY, nearestEnemy.x - playerX); const spreadAngle = this.projectileCount > 1 ? Math.PI / 12 : 0; const totalSpread = spreadAngle * (this.projectileCount - 1); const angleOffset = this.projectileCount > 1 ? (i * spreadAngle) - (totalSpread / 2) : 0; angle = baseAngle + angleOffset; } else { angle = 0; } const vx = Math.cos(angle) * this.projectileSpeed; const vy = Math.sin(angle) * this.projectileSpeed; projectiles.push(new Projectile(playerX, playerY, vx, vy, this.damage, this.emoji)); } } upgrade(type) { this.level++; if (type === 1) { this.projectileCount++; } else if (type === 2) { this.cooldown = Math.max(200, this.cooldown * 0.85); } this.damage += 5; } getDescription(type) { if (type === 1) return `🔪 Knife: +1 Projectile (Current: ${this.projectileCount})`; if (type === 2) return `🔪 Knife: Speed +15% (CD: ${(this.cooldown / 1000).toFixed(1)}s)`; return `🔪 Knife: Upgrade error`; } getNextUpgradeOptions() { return [ { text: this.getDescription(1), action: () => this.upgrade(1) }, { text: this.getDescription(2), action: () => this.upgrade(2) } ]; } }
        class OrbitalWeapon extends Weapon { constructor() { super(); this.emoji = '💫'; this.amount = 1; this.radius = 60; this.orbitSpeed = 1.5 * Math.PI; this.damage = 8; this.orbitAngle = 0; this.hitCooldown = 500; this.enemyHitTimers = new Map(); this.size = ORBITAL_SIZE; this.cooldown = 0; } update(dt, playerX, playerY) { if (gameState !== 'playing') return; this.orbitAngle += this.orbitSpeed * dt; const now = performance.now(); const activeEnemyIds = new Set(enemies.concat(currentBoss ? [currentBoss] : []).filter(e => e && e.active).map(e => e.id)); this.enemyHitTimers.forEach((time, enemy) => { if (!enemy || !enemy.active || !activeEnemyIds.has(enemy.id)) { this.enemyHitTimers.delete(enemy); } }); for (let i = 0; i < this.amount; i++) { const angle = this.orbitAngle + (i * (2 * Math.PI / this.amount)); const orbX = playerX + Math.cos(angle) * this.radius; const orbY = playerY + Math.sin(angle) * this.radius; enemies.concat(currentBoss ? [currentBoss] : []).forEach(enemy => { if (!enemy || !enemy.active) return; const dx = orbX - enemy.x; const dy = orbY - enemy.y; const distSq = dx*dx + dy*dy; const collisionDist = (this.size / 2 + enemy.size / 2); if (distSq < collisionDist * collisionDist) { const lastHitTime = this.enemyHitTimers.get(enemy) || 0; if (now - lastHitTime >= this.hitCooldown) { enemy.takeDamage(this.damage); this.enemyHitTimers.set(enemy, now); } } }); } } drawOver(ctx, playerX, playerY) { ctx.font = `${this.size * 1.5}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; for (let i = 0; i < this.amount; i++) { const angle = this.orbitAngle + (i * (2 * Math.PI / this.amount)); const orbX = playerX + Math.cos(angle) * this.radius; const orbY = playerY + Math.sin(angle) * this.radius; ctx.fillText(this.emoji, orbX, orbY); } } upgrade(type) { this.level++; this.damage += 2; if (type === 1) { if (this.amount < 6) this.amount++; } else if (type === 2) { this.radius *= 1.20; } else if (type === 3) { this.orbitSpeed *= 1.25; } } getDescription(type) { if (type === 1) return `💫 Guard: +1 Orb (Current: ${this.amount})`; if (type === 2) return `💫 Guard: Area +20% (Radius: ${this.radius.toFixed(0)})`; if (type === 3) return `💫 Guard: Speed +25%`; return `💫 Guard: Damage +5 (Current: ${this.damage})`; } getNextUpgradeOptions() { const options = []; if (this.amount < 6) options.push({ text: this.getDescription(1), action: () => this.upgrade(1) }); options.push({ text: this.getDescription(2), action: () => this.upgrade(2) }); options.push({ text: this.getDescription(3), action: () => this.upgrade(3) }); options.push({ text: `💫 Guard: Damage +5 (Current: ${this.damage})`, action: () => { this.damage += 5; this.level++; } }); return options; } }
        class AuraWeapon extends Weapon { constructor() { super(); this.emoji = '☣️'; this.auraRadius = 75; this.damage = 4; this.tickRate = 500; this.enemyHitTimers = new Map(); this.cooldown = 0; } update(dt, playerX, playerY) { if (gameState !== 'playing') return; const now = performance.now(); const radiusSq = this.auraRadius * this.auraRadius; const activeEnemyIds = new Set(enemies.concat(currentBoss ? [currentBoss] : []).filter(e => e && e.active).map(e => e.id)); this.enemyHitTimers.forEach((time, enemy) => { if (!enemy || !enemy.active || !activeEnemyIds.has(enemy.id)) { this.enemyHitTimers.delete(enemy); } }); enemies.concat(currentBoss ? [currentBoss] : []).forEach(enemy => { if (!enemy || !enemy.active) return; const dx = enemy.x - playerX; const dy = enemy.y - playerY; const distSq = dx*dx + dy*dy; if (distSq <= radiusSq) { const lastHitTime = this.enemyHitTimers.get(enemy) || 0; if (now - lastHitTime >= this.tickRate) { enemy.takeDamage(this.damage); this.enemyHitTimers.set(enemy, now); } } }); } drawUnder(ctx, playerX, playerY) { ctx.globalAlpha = 0.3; const fontSize = this.auraRadius * 1.8; ctx.font = `${fontSize}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.emoji, playerX, playerY); ctx.globalAlpha = 1.0; } upgrade(type) { this.level++; this.damage += 1; if (type === 1) { this.auraRadius *= 1.25; } else if (type === 2) { this.tickRate = Math.max(100, this.tickRate * 0.85); } } getDescription(type) { if (type === 1) return `☣️ Aura: Area +25% (Radius: ${this.auraRadius.toFixed(0)})`; if (type === 2) return `☣️ Aura: Tick Speed +15% (Rate: ${(this.tickRate/1000).toFixed(2)}s)`; return `☣️ Aura: Damage +2 (Current: ${this.damage})`; } getNextUpgradeOptions() { const options = []; options.push({ text: this.getDescription(1), action: () => this.upgrade(1) }); options.push({ text: this.getDescription(2), action: () => this.upgrade(2) }); options.push({ text: `☣️ Aura: Damage +2 (Current: ${this.damage})`, action: () => { this.damage += 2; this.level++; } }); return options; } }
        class FireballWeapon extends Weapon { constructor() { super(); this.emoji = '🔥'; this.cooldown = 1800; this.damage = 25; this.projectileSpeed = 120; this.projectileCount = 1; this.explosionRadius = 50; this.projectileLifespan = 2500; this.lastFireTime = performance.now(); } update(dt, playerX, playerY) { if (gameState !== 'playing') return; const now = performance.now(); if (now - this.lastFireTime >= this.cooldown) { this.fire(playerX, playerY); this.lastFireTime = now; } } fire(playerX, playerY) { let nearestEnemy = null; let minDistSq = Infinity; enemies.concat(currentBoss ? [currentBoss] : []).forEach(enemy => { if (!enemy || !enemy.active) return; const distSq = (enemy.x - playerX)**2 + (enemy.y - playerY)**2; if (distSq < minDistSq) { minDistSq = distSq; nearestEnemy = enemy; } }); for (let i = 0; i < this.projectileCount; i++) { let angle; if (nearestEnemy) { const baseAngle = Math.atan2(nearestEnemy.y - playerY, nearestEnemy.x - playerX); const spreadAngle = this.projectileCount > 1 ? Math.PI / 10 : 0; const totalSpread = spreadAngle * (this.projectileCount - 1); const angleOffset = this.projectileCount > 1 ? (i * spreadAngle) - (totalSpread / 2) : 0; angle = baseAngle + angleOffset; } else { angle = Math.PI * 1.5; } const vx = Math.cos(angle) * this.projectileSpeed; const vy = Math.sin(angle) * this.projectileSpeed; projectiles.push(new FireballProjectile(playerX, playerY, vx, vy, this.damage, this.explosionRadius, this.projectileLifespan, this.emoji)); } } upgrade(type) { this.level++; if (type === 1) { if (this.projectileCount < 5) this.projectileCount++; } else if (type === 2) { this.cooldown = Math.max(400, this.cooldown * 0.85); } else if (type === 3) { this.explosionRadius *= 1.20; } this.damage += 5; } getDescription(type) { if (type === 1) return `🔥 Fireball: +1 Projectile (Current: ${this.projectileCount})`; if (type === 2) return `🔥 Fireball: Speed +15% (CD: ${(this.cooldown / 1000).toFixed(1)}s)`; if (type === 3) return `🔥 Fireball: Explosion Area +20% (Radius: ${this.explosionRadius.toFixed(0)})`; return `🔥 Fireball: Expl. Damage +5 (Current: ${this.damage})`; } getNextUpgradeOptions() { const options = []; if (this.projectileCount < 5) options.push({ text: this.getDescription(1), action: () => this.upgrade(1) }); options.push({ text: this.getDescription(2), action: () => this.upgrade(2) }); options.push({ text: this.getDescription(3), action: () => this.upgrade(3) }); options.push({ text: `🔥 Fireball: Expl. Damage +5 (Current: ${this.damage})`, action: () => { this.damage += 5; this.level++; } }); return options; } }

        // --- Projectile Classes --- (Base, EnemyProjectile, FireballProjectile unchanged from V4)
        class Projectile { constructor(x, y, vx, vy, damage, emoji) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.damage = damage; this.emoji = emoji; this.size = PROJECTILE_SIZE; this.lifespan = 2000; this.spawnTime = performance.now(); this.active = true; } update(dt) { this.x += this.vx * dt; this.y += this.vy * dt; if (performance.now() - this.spawnTime > this.lifespan) { this.active = false; } const offscreenBuffer = 100; if (this.x < -offscreenBuffer || this.x > canvas.width + offscreenBuffer || this.y < -offscreenBuffer || this.y > canvas.height + offscreenBuffer) { this.active = false; } } draw(ctx) { ctx.font = `${this.size * 1.5}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.emoji, this.x, this.y); } }
        class EnemyProjectile { constructor(x, y, vx, vy, damage, emoji) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.damage = damage; this.emoji = emoji; this.size = ENEMY_PROJECTILE_SIZE; this.lifespan = 5000; this.spawnTime = performance.now(); this.active = true; } update(dt) { if (!this.active || gameState !== 'playing') return; this.x += this.vx * dt; this.y += this.vy * dt; if (performance.now() - this.spawnTime > this.lifespan) { this.active = false; } const offscreenBuffer = 50; if (this.x < -offscreenBuffer || this.x > canvas.width + offscreenBuffer || this.y < -offscreenBuffer || this.y > canvas.height + offscreenBuffer) { this.active = false; } } draw(ctx) { ctx.font = `${this.size * 1.5}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.emoji, this.x, this.y); } }
        class FireballProjectile extends Projectile {
            constructor(x, y, vx, vy, explosionDamage, explosionRadius, lifespan, emoji) { super(x, y, vx, vy, 0, emoji); this.explosionDamage = explosionDamage; this.explosionRadius = explosionRadius; this.lifespan = lifespan; this.size = FIREBALL_SIZE; this.exploded = false; }
            update(dt) { if (!this.active) return; this.x += this.vx * dt; this.y += this.vy * dt; const now = performance.now(); if (now - this.spawnTime > this.lifespan) { this.explode(); return; } enemies.concat(currentBoss ? [currentBoss] : []).forEach(enemy => { if (!this.active || !enemy || !enemy.active) return; const dx = this.x - enemy.x; const dy = this.y - enemy.y; const distSq = dx*dx + dy*dy; const collisionDist = (this.size / 2 + enemy.size / 2); if (distSq < collisionDist * collisionDist) { this.explode(); } }); const offscreenBuffer = 10; if (this.x < -offscreenBuffer || this.x > canvas.width + offscreenBuffer || this.y < -offscreenBuffer || this.y > canvas.height + offscreenBuffer) { this.explode(); } }
            explode() { if (!this.active || this.exploded) return; this.exploded = true; this.active = false; createExplosion(this.x, this.y, this.explosionRadius, this.explosionDamage); }
        }

        // --- Explosion Effect Class --- (FIXED draw method)
        class ExplosionEffect {
            constructor(x, y, maxRadius) {
                this.x = x; this.y = y;
                this.maxRadius = maxRadius;
                this.currentRadius = 0;
                this.lifespan = 300; // ms duration of effect
                this.startTime = performance.now();
                this.active = true;
                // We'll calculate color+alpha dynamically in draw
            }

            update(dt) {
                 if (!this.active) return;
                 const elapsed = performance.now() - this.startTime;
                 if (elapsed >= this.lifespan) {
                     this.active = false;
                     return;
                 }
                 const progress = elapsed / this.lifespan; // 0 to 1
                 this.currentRadius = this.maxRadius * progress;
            }

            draw(ctx) {
                 if (!this.active) return;
                 const elapsed = performance.now() - this.startTime;
                 const progress = Math.min(1, elapsed / this.lifespan); // Ensure progress doesn't exceed 1
                 const alpha = 0.8 * (1 - progress); // Fade out alpha
                 const colorR = 255;
                 const colorG = 165 - Math.floor(96 * progress); // Shift from orange to red
                 const colorB = 0;

                 ctx.globalAlpha = alpha; // Set alpha ONLY for this drawing operation
                 ctx.fillStyle = `rgba(${colorR}, ${colorG}, ${colorB}, 1)`; // Use rgb + globalAlpha
                 ctx.beginPath();
                 ctx.arc(this.x, this.y, this.currentRadius, 0, Math.PI * 2);
                 ctx.fill();
                 ctx.globalAlpha = 1.0; // --- FIX: Reset global alpha ---
            }
        }


        // --- Enemy & Boss Classes --- (UPDATED Boss constructor, Boss update, Enemy/Boss die)
        let nextEnemyId = 0;
        class Enemy {
             constructor(x, y, type, gameTimeRef) { this.id = nextEnemyId++; this.x = x; this.y = y; this.size = ENEMY_SIZE; this.type = type; this.active = true; this.speed = ENEMY_BASE_SPEED; this.damage = 10; const timeMultiplier = 1 + gameTimeRef / 90; this.baseXpValue = 1; switch (type) { case 'ogre': this.emoji = '👹'; this.maxHp = Math.floor(30 * timeMultiplier); this.baseXpValue = 2; this.speed *= 0.9; this.damage = 15; break; case 'ghost': this.emoji = '👻'; this.maxHp = Math.floor(10 * timeMultiplier); this.baseXpValue = 1; this.speed *= 1.5; this.damage = 8; break; case 'alien': this.emoji = '👽'; this.maxHp = Math.floor(25 * timeMultiplier); this.baseXpValue = 3; this.speed *= 1.0; this.damage = 12; break; case 'skull': default: this.emoji = '💀'; this.maxHp = Math.floor(15 * timeMultiplier); this.baseXpValue = 1; this.speed *= 1.1; this.damage = 10; break; } this.hp = this.maxHp; this.xpValue = this.baseXpValue; }
             update(dt, playerX, playerY) { if (!this.active || gameState !== 'playing') return; const dx = playerX - this.x; const dy = playerY - this.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist > 1) { const moveX = (dx / dist) * this.speed * dt; const moveY = (dy / dist) * this.speed * dt; this.x += moveX; this.y += moveY; } }
             draw(ctx) { ctx.font = `${this.size * 1.5}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.emoji, this.x, this.y); if (this.hp < this.maxHp) { const barWidth = this.size * 1.2, barHeight = 4, barX = this.x - barWidth / 2, barY = this.y + this.size * 0.75; ctx.fillStyle = '#6c757d'; ctx.fillRect(barX, barY, barWidth, barHeight); ctx.fillStyle = '#ffc107'; ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHp), barHeight); } }
             takeDamage(amount) { if (!this.active) return; this.hp -= amount; if (this.hp <= 0) { this.die(); } }
             die() { if (!this.active) return; this.active = false; for (let i = 0; i < this.baseXpValue; i++) { spawnXpGem(this.x + (Math.random() - 0.5) * 10, this.y + (Math.random() - 0.5) * 10, 1); } }
        }

        class Boss extends Enemy {
             constructor(x, y, gameTimeRef) {
                 super(x, y, 'boss', gameTimeRef);
                 this.emoji = '👾'; this.size = BOSS_SIZE;
                 const bossTimeMultiplier = 1 + gameTimeRef / 60;
                 // --- Reduced Base HP ---
                 this.maxHp = Math.floor(280 * bossTimeMultiplier * (currentWaveIndex/3 + 1));
                 this.hp = this.maxHp; this.baseXpValue = 50; this.speed = ENEMY_BASE_SPEED * 0.6; this.damage = 25;
                 this.fireCooldown = 2500; this.lastFireTime = performance.now() + 1000; this.projectileSpeed = 120; this.projectileDamage = 20; this.projectileEmoji = '☄️'; this.xpValue = this.baseXpValue;
                 // --- XP Trail properties ---
                 this.xpTrailTimer = 0;
                 this.xpTrailInterval = 400; // ms between drops
             }
             update(dt, playerX, playerY) {
                 super.update(dt, playerX, playerY); // Handles movement

                 if (this.active && gameState === 'playing') {
                     // Firing logic
                     const now = performance.now();
                     if (now - this.lastFireTime >= this.fireCooldown) {
                         this.fire(playerX, playerY);
                         this.lastFireTime = now;
                     }
                     // XP Trail logic --- NEW ---
                     this.xpTrailTimer += dt * 1000;
                     while (this.xpTrailTimer >= this.xpTrailInterval) { // Use while loop for fast updates
                          spawnXpGem(this.x + (Math.random() - 0.5) * this.size * 0.6, // Spawn near center
                                     this.y + (Math.random() - 0.5) * this.size * 0.6,
                                     1); // Spawn 1 XP gem
                          this.xpTrailTimer -= this.xpTrailInterval;
                     }
                 }
                 updateBossUI(this.hp, this.maxHp);
             }
             fire(playerX, playerY) { /* Unchanged */ const angle = Math.atan2(playerY - this.y, playerX - this.x); const vx = Math.cos(angle) * this.projectileSpeed; const vy = Math.sin(angle) * this.projectileSpeed; enemyProjectiles.push(new EnemyProjectile(this.x, this.y, vx, vy, this.projectileDamage, this.projectileEmoji)); }
             takeDamage(amount) { /* Unchanged, still calls die() */ if (!this.active) return; this.hp -= amount; updateBossUI(this.hp, this.maxHp); if (this.hp <= 0) { this.die(); } }
             die() { // Boss specific death actions (calls base for XP, then bossDefeated)
                 if (!this.active) return;
                 // Drop standard gems (handled by base class now?) - Let's keep specific drops here too
                 for(let i = 0; i < this.baseXpValue; i++) { spawnXpGem(this.x + (Math.random() - 0.5) * 60, this.y + (Math.random() - 0.5) * 60, 1); }
                 for (let i = 0; i < 5; i++) { spawnXpGem(this.x + (Math.random() - 0.5) * 60, this.y + (Math.random() - 0.5) * 60, 5); }
                 // Call base die to set active = false AFTER dropping gems maybe? Or just set here.
                 this.active = false;
                 bossDefeated(); // Call game logic transition AFTER dropping loot and setting inactive
             }
             draw(ctx) { /* Unchanged */ ctx.font = `${this.size * 1.5}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.emoji, this.x, this.y); }
        }

        // --- Pickup Classes --- (XP Gem, Chest, Health unchanged, Bomb Pickup unchanged)
        class XpGem { constructor(x, y, value) { this.x = x; this.y = y; this.value = value; this.size = GEM_SIZE; this.emoji = '✨'; this.active = true; this.currentMagnetSpeed = 0; this.isMagnetized = false; } update(dt, playerRef) { if (!this.active || gameState !== 'playing') return; const playerX = playerRef.x, playerY = playerRef.y, pickupRadius = playerRef.pickupRadius; const dx = playerX - this.x, dy = playerY - this.y; const distSq = dx*dx + dy*dy; const pickupRadiusSq = pickupRadius * pickupRadius; if (distSq < pickupRadiusSq || this.isMagnetized) { this.isMagnetized = true; const dist = Math.sqrt(distSq); this.currentMagnetSpeed += GEM_MAGNET_ACCELERATION * dt; this.currentMagnetSpeed = Math.min(this.currentMagnetSpeed, GEM_MAX_MAGNET_SPEED); if (dist > 1) { const moveX = (dx / dist) * this.currentMagnetSpeed * dt; const moveY = (dy / dist) * this.currentMagnetSpeed * dt; if (moveX * moveX + moveY * moveY >= distSq && dist > 0) { this.x = playerX; this.y = playerY; } else { this.x += moveX; this.y += moveY; } } const collisionThreshold = (playerRef.size / 4 + this.size / 2); if (dist < collisionThreshold) { playerRef.gainXp(this.value); this.active = false; } } else { this.isMagnetized = false; this.currentMagnetSpeed = 0; } } draw(ctx) { ctx.font = `${this.size * 1.5}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.globalAlpha = this.isMagnetized ? (Math.sin(performance.now() / 100) * 0.25 + 0.75) : 1.0; ctx.fillText(this.emoji, this.x, this.y); ctx.globalAlpha = 1.0; } }
        class TreasureChest { constructor(x, y) { this.x = x; this.y = y; this.size = CHEST_SIZE; this.emoji = '🎁'; this.active = true; this.spawnTime = performance.now(); this.lifespan = CHEST_LIFESPAN; this.xpRewardCount = CHEST_XP_REWARD; } update(dt) { if (!this.active) return; if (performance.now() - this.spawnTime > this.lifespan) { this.active = false; } } draw(ctx) { if (!this.active) return; ctx.font = `${this.size * 1.5}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const timeRemainingRatio = Math.max(0, (this.lifespan - (performance.now() - this.spawnTime))) / this.lifespan; ctx.globalAlpha = 0.6 + 0.4 * timeRemainingRatio; ctx.fillText(this.emoji, this.x, this.y); ctx.globalAlpha = 1.0; } collect() { if (!this.active) return; this.active = false; spawnChestLoot(this.x, this.y, this.xpRewardCount); } }
        class HealthPickup { constructor(x, y) { this.x = x; this.y = y; this.size = HEALTH_PICKUP_SIZE; this.emoji = '❤️'; this.active = true; this.spawnTime = performance.now(); this.lifespan = HEALTH_PICKUP_LIFESPAN; } update(dt) { if (!this.active) return; if (performance.now() - this.spawnTime > this.lifespan) { this.active = false; } } draw(ctx) { if (!this.active) return; ctx.font = `${this.size * 1.5}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const timeRemainingRatio = Math.max(0, (this.lifespan - (performance.now() - this.spawnTime))) / this.lifespan; ctx.globalAlpha = 0.5 + 0.5 * timeRemainingRatio; ctx.fillText(this.emoji, this.x, this.y); ctx.globalAlpha = 1.0; } collect(playerRef) { if (!this.active) return; this.active = false; playerRef.restoreFullHealth(); } }
        class BombPickup { constructor(x, y) { this.x = x; this.y = y; this.size = BOMB_PICKUP_SIZE; this.emoji = '💣'; this.active = true; this.spawnTime = performance.now(); this.lifespan = BOMB_PICKUP_LIFESPAN; } update(dt) { if (!this.active) return; if (performance.now() - this.spawnTime > this.lifespan) { this.active = false; } } draw(ctx) { if (!this.active) return; ctx.font = `${this.size * 1.5}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const pulse = Math.sin(performance.now() / 150) * 0.2 + 0.8; ctx.globalAlpha = pulse; ctx.fillText(this.emoji, this.x, this.y); ctx.globalAlpha = 1.0; } collect(playerRef) { if (!this.active) return; this.active = false; console.log("💣 BOOM! Clearing enemies."); createExplosion(this.x, this.y, 100, 0); enemies.forEach(enemy => { if (enemy.active) enemy.die(); }); } }

        // --- Game Functions --- (init, resize, spawning, explosion unchanged from V4)
        function init() { resizeCanvas(); player = new Player(canvas.width / 2, canvas.height / 2); enemies = []; projectiles = []; enemyProjectiles = []; xpGems = []; treasureChests = []; healthPickups = []; bombPickups = []; explosionEffects = []; keys = {}; gameTime = 0; isFirstFrame = true; nextEnemyId = 0; currentWaveIndex = 0; waveTimer = 0; enemySpawnTimer = 0; chestSpawnTimer = 0; healthSpawnTimer = 0; bombSpawnTimer = 0; isBossActive = false; currentBoss = null; hideBossUI(); gameState = 'playing'; gameOverScreen.style.display = 'none'; levelUpModal.style.display = 'none'; updateUI(); if (gameLoopId) cancelAnimationFrame(gameLoopId); gameLoopId = requestAnimationFrame(gameLoop); }
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; if(player) { player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, player.x)); player.y = Math.max(player.size / 2, Math.min(canvas.height - player.size / 2, player.y)); } }
        function spawnEnemy(enemyType) { const edge = Math.floor(Math.random() * 4); let x, y; const buffer = 50; switch (edge) { case 0: x = Math.random() * canvas.width; y = -buffer; break; case 1: x = canvas.width + buffer; y = Math.random() * canvas.height; break; case 2: x = Math.random() * canvas.width; y = canvas.height + buffer; break; case 3: x = -buffer; y = Math.random() * canvas.height; break; } enemies.push(new Enemy(x, y, enemyType, gameTime)); }
        function spawnBoss() { const edge = Math.floor(Math.random() * 4); let x, y; const buffer = 150; switch (edge) { case 0: x = canvas.width / 2; y = -buffer; break; case 1: x = canvas.width + buffer; y = canvas.height/2; break; case 2: x = canvas.width / 2; y = canvas.height + buffer; break; case 3: x = -buffer; y = canvas.height/2; break; } console.log(`Spawning Boss at Wave ${currentWaveIndex + 1}`); currentBoss = new Boss(x, y, gameTime); isBossActive = true; showBossUI(); }
        function spawnXpGem(x, y, value) { xpGems.push(new XpGem(x, y, value)); }
        function spawnTreasureChest() { if (treasureChests.length > 0 || isBossActive) return; const margin = 50; const x = Math.random() * (canvas.width - margin * 2) + margin; const y = Math.random() * (canvas.height - margin * 2) + margin; console.log("Spawning Treasure Chest!"); treasureChests.push(new TreasureChest(x, y)); }
        function spawnChestLoot(x, y, count) { console.log(`Spawning ${count} gems from chest`); for (let i = 0; i < count; i++) { spawnXpGem(x + (Math.random() - 0.5) * 40, y + (Math.random() - 0.5) * 40, 1); } }
        function spawnHealthPickup() { if (healthPickups.length > 0 || isBossActive || !player || player.hp >= player.maxHp) return; const margin = 50; const x = Math.random() * (canvas.width - margin * 2) + margin; const y = Math.random() * (canvas.height - margin * 2) + margin; console.log("Spawning Health Pickup!"); healthPickups.push(new HealthPickup(x, y)); }
        function spawnBombPickup() { if (bombPickups.length > 0 || isBossActive) return; const margin = 100; const x = Math.random() * (canvas.width - margin * 2) + margin; const y = Math.random() * (canvas.height - margin * 2) + margin; console.log("Spawning Bomb Pickup!"); bombPickups.push(new BombPickup(x, y)); }
        function createExplosion(x, y, radius, damage) { explosionEffects.push(new ExplosionEffect(x, y, radius)); if (damage <= 0) return; const radiusSq = radius * radius; enemies.concat(currentBoss ? [currentBoss] : []).forEach(enemy => { if (!enemy || !enemy.active) return; const dx = enemy.x - x; const dy = enemy.y - y; const distSq = dx*dx + dy*dy; if (distSq <= radiusSq) { enemy.takeDamage(damage); } }); }

        // --- Collision Checks --- (unchanged from V4)
        function checkCollisions() { enemies.concat(currentBoss ? [currentBoss] : []).forEach(enemy => { if (!enemy || !enemy.active || !player) return; const dx = player.x - enemy.x; const dy = player.y - enemy.y; const distSq = dx*dx + dy*dy; const collisionDist = (player.size / 2 + enemy.size / 2); if (distSq < collisionDist * collisionDist) { player.takeDamage(enemy.damage); } }); enemyProjectiles.forEach(ep => { if (!ep.active || !player) return; const dx = player.x - ep.x; const dy = player.y - ep.y; const distSq = dx*dx + dy*dy; const collisionDist = (player.size / 2 + ep.size / 2); if (distSq < collisionDist * collisionDist) { player.takeDamage(ep.damage); ep.active = false; } }); projectiles.forEach(projectile => { if (!projectile.active || projectile instanceof FireballProjectile) return; enemies.concat(currentBoss ? [currentBoss] : []).forEach(enemy => { if (!enemy || !enemy.active || !projectile.active) return; const dx = projectile.x - enemy.x; const dy = projectile.y - enemy.y; const distSq = dx*dx + dy*dy; const collisionDist = (projectile.size / 2 + enemy.size / 2); if (distSq < collisionDist * collisionDist) { enemy.takeDamage(projectile.damage); projectile.active = false; } }); }); treasureChests.forEach(chest => { if (!chest.active || !player) return; const dx = player.x - chest.x; const dy = player.y - chest.y; const distSq = dx*dx + dy*dy; const collisionDist = (player.size / 2 + chest.size / 2); if (distSq < collisionDist * collisionDist) { chest.collect(); } }); healthPickups.forEach(hpItem => { if (!hpItem.active || !player) return; const dx = player.x - hpItem.x; const dy = player.y - hpItem.y; const distSq = dx*dx + dy*dy; const collisionDist = (player.size / 2 + hpItem.size / 2); if (distSq < collisionDist * collisionDist) { hpItem.collect(player); } }); bombPickups.forEach(bomb => { if (!bomb.active || !player) return; const dx = player.x - bomb.x; const dy = player.y - bomb.y; const distSq = dx*dx + dy*dy; const collisionDist = (player.size / 2 + bomb.size / 2); if (distSq < collisionDist * collisionDist) { bomb.collect(player); } }); }

         // --- Update Function --- (unchanged from V4)
         function update(dt) { gameTime += dt; waveTimer += dt; chestSpawnTimer += dt; healthSpawnTimer += dt; bombSpawnTimer += dt; const currentWave = waveData[currentWaveIndex]; if (!currentWave.boss && currentWave.duration !== Infinity && waveTimer >= currentWave.duration) { waveTimer = 0; currentWaveIndex++; if (currentWaveIndex >= waveData.length) currentWaveIndex = waveData.length - 1; if (!waveData[currentWaveIndex].boss) enemySpawnTimer = 0; console.log(`Advancing to Wave ${currentWaveIndex + 1}`); updateUI(); } if (gameState === 'playing') { const waveInfo = waveData[currentWaveIndex]; if (waveInfo.boss && !isBossActive && !currentBoss) spawnBoss(); else if (!waveInfo.boss || !isBossActive) { const spawnInterval = ENEMY_SPAWN_INTERVAL_BASE / waveInfo.density; enemySpawnTimer += dt * 1000; while (enemySpawnTimer >= spawnInterval && enemies.length < 150) { const enemyTypeToSpawn = waveInfo.types[Math.floor(Math.random() * waveInfo.types.length)]; spawnEnemy(enemyTypeToSpawn); enemySpawnTimer -= spawnInterval; } } } if (gameState === 'playing' && !isBossActive) { if (treasureChests.length === 0 && chestSpawnTimer >= 1) { if (Math.random() < CHEST_SPAWN_CHANCE) spawnTreasureChest(); chestSpawnTimer = 0; } if (healthPickups.length === 0 && player && player.hp < player.maxHp && healthSpawnTimer >= 1) { if (Math.random() < HEALTH_SPAWN_CHANCE) spawnHealthPickup(); healthSpawnTimer = 0; } if (bombPickups.length === 0 && bombSpawnTimer >= 1) { if (Math.random() < BOMB_SPAWN_CHANCE) spawnBombPickup(); bombSpawnTimer = 0; } } if (player) player.update(dt); enemies.forEach(enemy => enemy.update(dt, player.x, player.y)); if (currentBoss && currentBoss.active) currentBoss.update(dt, player.x, player.y); projectiles.forEach(projectile => projectile.update(dt)); enemyProjectiles.forEach(ep => ep.update(dt)); xpGems.forEach(gem => gem.update(dt, player)); treasureChests.forEach(chest => chest.update(dt)); healthPickups.forEach(hpItem => hpItem.update(dt)); bombPickups.forEach(bomb => bomb.update(dt)); explosionEffects.forEach(effect => effect.update(dt)); checkCollisions(); enemies = enemies.filter(e => e.active); projectiles = projectiles.filter(p => p.active); enemyProjectiles = enemyProjectiles.filter(ep => ep.active); xpGems = xpGems.filter(g => g.active); treasureChests = treasureChests.filter(chest => chest.active); healthPickups = healthPickups.filter(hpItem => hpItem.active); bombPickups = bombPickups.filter(bomb => bomb.active); explosionEffects = explosionEffects.filter(effect => effect.active); updateUI(); }

         // --- Boss Handling & UI --- (UPDATED bossDefeated)
         function bossDefeated() {
             console.log("Boss Defeated!");
             isBossActive = false;
             currentBoss = null; // Set boss to null
             hideBossUI();

             // --- Grant Level Up Reward ---
             console.log("Boss defeat reward: Triggering Level Up!");
             pauseGameForLevelUp(); // Show level up modal immediately

             // Wave progression happens *after* level up screen potentially resolves
             waveTimer = 0;
             currentWaveIndex++;
             if (currentWaveIndex >= waveData.length) {
                 currentWaveIndex = waveData.length - 1; // Stay on last wave type
             }
             enemySpawnTimer = 0; // Reset normal enemy spawn timer
             updateUI(); // Update wave display etc.
         }
         function showBossUI() { bossInfoDiv.style.display = 'block'; }
         function hideBossUI() { bossInfoDiv.style.display = 'none'; }
         function updateBossUI(currentHp, maxHp) { if (!isBossActive) return; const hpPercent = Math.max(0, currentHp) / maxHp * 100; bossHpFillDiv.style.width = `${hpPercent}%`; }

        // --- Draw Function --- (unchanged from V4)
        function draw() { ctx.fillStyle = '#333'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = '#444'; ctx.lineWidth = 0.5; ctx.beginPath(); for (let x = 0; x <= canvas.width; x += GRID_SIZE) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); } for (let y = 0; y <= canvas.height; y += GRID_SIZE) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); } ctx.stroke(); xpGems.forEach(gem => gem.draw(ctx)); treasureChests.forEach(chest => chest.draw(ctx)); healthPickups.forEach(hpItem => hpItem.draw(ctx)); bombPickups.forEach(bomb => bomb.draw(ctx)); explosionEffects.forEach(effect => effect.draw(ctx)); enemyProjectiles.forEach(ep => ep.draw(ctx)); enemies.forEach(enemy => enemy.draw(ctx)); if (currentBoss) currentBoss.draw(ctx); projectiles.forEach(projectile => projectile.draw(ctx)); if (player) player.draw(ctx); }

        // --- UI Update, Level Up, Pause/Resume --- (unchanged from V4)
         function updateUI() { if (!player) return; uiHp.textContent = Math.max(0, player.hp).toFixed(0); uiMaxHp.textContent = player.maxHp.toFixed(0); uiLevel.textContent = player.level; uiXp.textContent = player.xp.toFixed(0); uiNextLevelXp.textContent = player.nextLevelXp.toFixed(0); uiWave.textContent = currentWaveIndex + 1; uiArmor.textContent = player.armor.toFixed(0); uiXpMult.textContent = `${player.xpMultiplier.toFixed(1)}x`; const totalSeconds = Math.floor(gameTime); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; if (!isNaN(minutes) && !isNaN(seconds)) { uiTimer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`; } else { uiTimer.textContent = "0:00"; } }
         function pauseGameForLevelUp() { if (gameState !== 'playing') return; /* Prevent multiple calls */ gameState = 'leveling'; displayLevelUpOptions(); levelUpModal.style.display = 'block'; }
         function resumeGame() { levelUpModal.style.display = 'none'; gameState = 'playing'; lastTime = performance.now(); if (!gameLoopId) gameLoopId = requestAnimationFrame(gameLoop); }
         function displayLevelUpOptions() { const availableUpgrades = getAvailableUpgrades(3); availableUpgrades.forEach((upgrade, index) => { if (upgrade && upgradeOptionButtons[index]) { upgradeOptionButtons[index].textContent = upgrade.text; const oldButton = upgradeOptionButtons[index]; const newButton = oldButton.cloneNode(true); oldButton.parentNode.replaceChild(newButton, oldButton); newButton.addEventListener('click', () => { if (gameState === 'leveling') { upgrade.action(); resumeGame(); } }, { once: true }); upgradeOptionButtons[index] = newButton; newButton.style.display = 'block'; newButton.disabled = false; } else if(upgradeOptionButtons[index]) { upgradeOptionButtons[index].style.display = 'none'; } }); }

         // --- Get Available Upgrades --- (unchanged from V4)
         function getAvailableUpgrades(count) { const possibleUpgrades = []; player.weapons.forEach(weapon => { possibleUpgrades.push(...weapon.getNextUpgradeOptions()); }); if (player.weapons.length < MAX_WEAPONS) { if (!player.weapons.some(w => w instanceof OrbitalWeapon)) { possibleUpgrades.push({ text: `✨ Unlock: 💫 Orbital Guard Lv.1`, action: () => player.addWeapon(new OrbitalWeapon()) }); } if (!player.weapons.some(w => w instanceof AuraWeapon)) { possibleUpgrades.push({ text: `✨ Unlock: ☣️ Toxic Aura Lv.1`, action: () => player.addWeapon(new AuraWeapon()) }); } if (!player.weapons.some(w => w instanceof FireballWeapon)) { possibleUpgrades.push({ text: `✨ Unlock: 🔥 Fireball Lv.1`, action: () => player.addWeapon(new FireballWeapon()) }); } } possibleUpgrades.push({ text: `❤️ Max HP +20 (Current: ${player.maxHp.toFixed(0)})`, action: () => { player.maxHp += 20; player.hp = Math.min(player.maxHp, player.hp + 20); } }); possibleUpgrades.push({ text: `👟 Move Speed +10% (Current: ${(player.speed / PLAYER_SPEED * 100).toFixed(0)}%)`, action: () => { player.speed *= 1.10; } }); possibleUpgrades.push({ text: `🧲 Pickup Radius +25% (Current: ${player.pickupRadius.toFixed(0)})`, action: () => { player.pickupRadius *= 1.25; } }); possibleUpgrades.push({ text: `🛡️ Armor +1 (Current: ${player.armor.toFixed(0)})`, action: () => { player.armor += 1; } }); possibleUpgrades.push({ text: `🌱 Growth +10% XP (Current: ${player.xpMultiplier.toFixed(1)}x)`, action: () => { player.xpMultiplier += 0.1; } }); if (player.weapons.length > 0) { possibleUpgrades.push({ text: `⏱️ All Weapons: Cooldown -10%`, action: () => { player.weapons.forEach(w => { if (w.cooldown > 0) w.cooldown = Math.max(w instanceof FireballWeapon ? 400 : 100, w.cooldown * 0.9); }); } }); possibleUpgrades.push({ text: `💪 All Weapons: Damage +10%`, action: () => { player.weapons.forEach(w => w.damage = Math.ceil(w.damage * 1.1)); } }); } const shuffled = possibleUpgrades.sort(() => 0.5 - Math.random()); const uniqueUpgrades = []; const seenTexts = new Set(); for (const upgrade of shuffled) { if (!seenTexts.has(upgrade.text)) { uniqueUpgrades.push(upgrade); seenTexts.add(upgrade.text); } if (uniqueUpgrades.length >= count) break; } while(uniqueUpgrades.length < count && uniqueUpgrades.length < shuffled.length){ const nextUpgrade = shuffled[uniqueUpgrades.length]; if(nextUpgrade) uniqueUpgrades.push(nextUpgrade); else break; } return uniqueUpgrades.slice(0, count); }

        // --- Game Over, Game Loop, Event Listeners --- (unchanged from V4)
         function gameOver() { if (gameState === 'gameOver') return; gameState = 'gameOver'; finalTimeEl.textContent = uiTimer.textContent; finalLevelEl.textContent = player ? player.level : 1; finalWaveEl.textContent = currentWaveIndex + 1; gameOverScreen.style.display = 'block'; hideBossUI(); if (gameLoopId) cancelAnimationFrame(gameLoopId); gameLoopId = null; }
        function gameLoop(timestamp) { if (isFirstFrame) { lastTime = timestamp; isFirstFrame = false; } deltaTime = (timestamp - lastTime) / 1000; lastTime = timestamp; const MAX_DELTA_TIME = 0.1; const MIN_DELTA_TIME = 0.001; if (isNaN(deltaTime) || deltaTime <= 0) deltaTime = MIN_DELTA_TIME; else deltaTime = Math.min(deltaTime, MAX_DELTA_TIME); if (gameState === 'playing' || gameState === 'leveling') { if (gameState === 'playing') { update(deltaTime); } draw(); /* Draw even when leveling */ } if (gameState !== 'gameOver') gameLoopId = requestAnimationFrame(gameLoop); else gameLoopId = null; } // Modified loop to draw during 'leveling'
        window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true ); window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false ); window.addEventListener('resize', resizeCanvas); restartButton.addEventListener('click', () => init() );

        // --- Start Game ---
        init();

    </script>

</body>
</html>
